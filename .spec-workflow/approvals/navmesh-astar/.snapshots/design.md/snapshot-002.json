{
  "id": "snapshot_1760128306277_93kud4w2d",
  "approvalId": "approval_1760128276153_pumy3h5x1",
  "approvalTitle": "Design: navmesh-astar",
  "version": 2,
  "timestamp": "2025-10-10T20:31:46.277Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design: navmesh-astar\n\n## Overview\nImplement a region-graph-backed pathfinding provider that runs the same deterministic A* (`navpath/astar.py`) and preserves the public API, CLI, outputs, and behaviors of `navpath`, while using `navmesh.db` as the data source. The design introduces a `NavmeshDatabase` and `NavmeshGraphProvider` which adapt region connectivity (`nav_regions`, `nav_region_edges`) to tile-based edges so that the rest of the system remains unchanged.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Reuse existing interfaces (`GraphProvider`, `CostModel`, `SearchOptions`, `PathResult`) to minimize surface changes.\n- Maintain deterministic ordering and stable tie-breaking as in `navpath/astar.py` and `navpath/graph.py`.\n- Read-only SQLite access with parameterized queries, mirroring `navpath/db.py`.\n\n### Project Structure (structure.md)\n- Add new modules under `navpath/` without altering consumer entrypoints:\n  - `navpath/navmesh_db.py` — DB helpers for `navmesh.db`.\n  - `navpath/navmesh_graph.py` — `GraphProvider` implementation over regions.\n  - Optional small utilities: `navpath/mesh_tiles.py` for tile selection within regions.\n- Keep `navpath/api.py`, `navpath/__main__.py`, `navpath/astar.py`, `navpath/path.py`, `navpath/options.py` intact aside from provider selection wiring.\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`navpath/astar.py`**: Deterministic A* and reconstruction remain unchanged.\n- **`navpath/path.py`**: `PathResult`, `ActionStep`, `NodeRef` JSON models unchanged.\n- **`navpath/options.py`**: All flags/limits/cost overrides reused.\n- **`navpath/cost.py`**: Cost semantics reused; movement/node overrides honored.\n- **`navpath/requirements.py`**: Requirement evaluation logic reused.\n\n### Integration Points\n- **`navpath/api.find_path()`**: Detect DB type at runtime and instantiate the proper provider:\n  - If `nav_regions` exists → `NavmeshDatabase + NavmeshGraphProvider`.\n  - Else → current `Database + SqliteGraphProvider`.\n- **Logging**: Preserve the metrics line emitted in `navpath/api.py`.\n\n## Architecture\n\n- The A* search state remains tile-based. The navmesh provider maps the current tile to its `src_region_id` and yields neighbor edges to destination tiles determined by region edges and metadata.\n- Costs are derived from `nav_region_edges.weight` with overrides applied for per-type categories (door, lodestone, object, ifslot, npc, item). Movement edges use the configured movement step cost.\n- Deterministic neighbor ordering matches existing rules: stable by type-specific keys and destination, producing consistent queues.\n\n```mermaid\nflowchart TD\n    A[api.find_path] -->|detect db type| B{DB has nav_regions?}\n    B -- Yes --> C[NavmeshDatabase]\n    B -- No --> D[Database]\n    C --> E[NavmeshGraphProvider]\n    D --> F[SqliteGraphProvider]\n    E -->|neighbors| G[astar]\n    F -->|neighbors| G\n    G --> H[reconstruct actions]\n    H --> I[PathResult]\n```\n\n## Components and Interfaces\n\n### `NavmeshDatabase`\n- **Purpose:** Read-only helper for `navmesh.db` tables with typed rows.\n- **Interfaces:**\n  - `connect(path) -> NavmeshDatabase`\n  - `fetch_region_by_tile(x,y,p) -> Optional[RegionRow]`\n  - `iter_region_edges(src_region_id) -> Iterator[RegionEdgeRow]`\n  - `iter_region_tiles(region_id) -> Iterator[Tile]`\n  - `tile_exists(tile: Tile) -> bool`\n  - `fetch_metadata_key(key: str) -> Optional[str]`\n- **Reuses:** Connection strategy from `navpath/db.py.open_connection` adapted to navmesh.\n\n### `NavmeshGraphProvider(GraphProvider)`\n- **Purpose:** Yield deterministic tile-to-tile edges computed from region graph.\n- **Interfaces:** `neighbors(tile: Tile, goal: Tile, options: SearchOptions) -> Iterable[Edge]` (same as `SqliteGraphProvider`).\n- **Dependencies:** `NavmeshDatabase`, `CostModel`, `SearchOptions`, `evaluate_requirement`.\n- **Edge generation strategy:**\n  1. Resolve `src_region` via `region_tiles` index; if None, raise `TileNotFoundError` → API returns `\"tile-not-found\"`.\n  2. Movement edges: from `nav_region_edges` where `type='move'`, use `meta.border_sample` to choose the exact `(from,to)` tile pair across the border; fallback to deterministic scan of shared boundary if sample missing.\n  3. Special edges (`door|lodestone|object|ifslot|npc|item`):\n     - Requirement gating via `meta.requirement_id` against `requirements` table when present; otherwise treat missing rows as unmet.\n     - Destination tile selection:\n       - Prefer explicit sample if present in `meta` (e.g., `border_sample.to`).\n       - Else choose the first existing tile in destination region by ascending `(x,y)`; plane from region.\n     - Cost: start from `weight` and apply type-specific overrides from `SearchOptions` via `CostModel`.\n     - Chain semantics: if `meta.chain` exists, embed it into `Edge.metadata['chain']` so `_reconstruct()` expands into multiple `ActionStep`s. Otherwise, emit as single-step (compatible default).\n  4. Lodestones only emitted from `options.extras['start_tile']` (same branching reduction as tiles provider).\n  5. Deterministic sort: stable per-type keys, then `to_tile`, then node id when available.\n\n### Utility: `TileSelector`\n- **Purpose:** Deterministically pick a concrete tile inside a region or along a border.\n- **Rules:** Scan `x` then `y`; ensure tile exists via `tile_exists()`; prefer border samples when available.\n\n## Data Models\n\n### `RegionRow`\n- `id: int`\n- `plane: int`\n- `min_x: int; min_y: int; max_x: int; max_y: int`\n- `area: int`\n- `category: Optional[str]`\n- `meta: Optional[str]` (raw JSON)\n\n### `RegionEdgeRow`\n- `src_region_id: int`\n- `dst_region_id: int`\n- `weight: int` (ms)\n- `type: str` in {`move`,`door`,`lodestone`,`object`,`ifslot`,`npc`,`item`}\n- `meta: Optional[str]` (JSON with per-type fields; may include `border_sample`, `head_id`, `requirement_id`, and optional flattened `chain`)\n\n## Error Handling\n\n### Error Scenarios\n1. **Unknown input tile**\n   - **Handling:** Raise `TileNotFoundError`; API returns `reason=\"tile-not-found\"`.\n   - **User Impact:** Clear message, no crash.\n2. **Malformed meta JSON**\n   - **Handling:** Log at DEBUG, skip the edge; continue search.\n   - **User Impact:** Potentially fewer edges; determinism preserved.\n3. **Missing `requirements` row for `requirement_id`**\n   - **Handling:** Treat as unmet; increment `req_filtered_count`.\n   - **User Impact:** Edge gated out.\n4. **No tile found in destination region**\n   - **Handling:** Skip edge; continue.\n5. **Timeout/expansion limit**\n   - **Handling:** Same as existing A*; return `timeout` or `max-expansions`.\n\n## Testing Strategy\n\n### Unit Testing\n- `NavmeshTileSelector`: deterministic tile selection and border sampling.\n- `NavmeshGraphProvider.neighbors()`: per-type edge generation, gating, costs, and ordering.\n\n### Integration Testing\n- End-to-end parity via CLI using `--json` and `--json-actions-only` to compare shapes with the tiles-based provider on controlled cases.\n- Mixed DB detection: verify `api.find_path()` picks the correct provider given `db_path`.\n\n### End-to-End Testing\n- Large representative routes: assert determinism and performance targets (≥2× fewer expansions vs. tiles on large open areas where applicable).\n- Requirements gating scenarios exercising pass/fail and missing rows.\n\n## Implementation Plan (high level)\n- Add `navmesh_db.py` with typed row helpers and read-only connection.\n- Add `navmesh_graph.py` implementing `GraphProvider` using `NavmeshDatabase`:\n  - Movement edges from `nav_region_edges(type='move')` with `border_sample`.\n  - Special edges with requirement gating and optional `chain` metadata.\n- Update `api.find_path()` to detect DB type and choose provider; keep signature and logging unchanged.\n- Keep `_reconstruct()` in `astar.py` unchanged; it already expands `Edge.metadata['chain']` when present.\n- Preserve CLI flags and `SearchOptions` mapping without changes.\n",
  "fileStats": {
    "size": 7925,
    "lines": 144,
    "lastModified": "2025-10-10T20:31:01.794Z"
  },
  "comments": []
}