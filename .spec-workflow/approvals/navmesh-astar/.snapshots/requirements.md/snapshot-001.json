{
  "id": "snapshot_1760127961239_avp26j3i4",
  "approvalId": "approval_1760127961237_8byad5lp7",
  "approvalTitle": "Requirements: navmesh-astar",
  "version": 1,
  "timestamp": "2025-10-10T20:26:01.239Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements: navmesh-astar\n\n## Introduction\nImplement A* pathfinding over the region-based navigation mesh stored in `navmesh.db`, providing the same public API, CLI options, output formats, and behavior as the existing tile/node-based `navpath` implementation. The new implementation must remain a drop-in replacement from a caller’s perspective.\n\n## Alignment with Product Vision\n- Reuse the deterministic A* patterns, options, and result models from `navpath` to ensure consistent UX across data backends.\n- Add support for region-graph navigation (`nav_regions`, `nav_region_edges`) to leverage pre-aggregated connectivity for performance and scalability.\n\n## Requirements\n\n### R1: Public API parity\n**User Story:** As an integrator, I want the same `find_path()` API so that I can switch to navmesh without code changes.\n\n- The function signature remains `find_path(start, goal, options=None, db_path=None) -> PathResult` (see `navpath/api.py`).\n- `start`, `goal` are tiles `(x,y,plane)` with the same validation rules as `navpath`.\n- `db_path` points to a `navmesh.db` by default; an explicit path or `options.extras['db_path']` overrides it.\n- Returns the same `PathResult` object shape with identical fields and semantics.\n\n#### Acceptance Criteria\n1. WHEN calling `find_path((x1,y1,p),(x2,y2,p))` with a valid `navmesh.db` THEN the return type is `PathResult` with identical JSON shape to `navpath`.\n2. IF inputs are not `(int,int,int)` tuples THEN reason SHALL be `\"invalid-input\"`.\n3. IF either tile is not present in `region_tiles` THEN reason SHALL be `\"tile-not-found\"`.\n\n### R2: CLI parity\n**User Story:** As a CLI user, I want identical flags and outputs so that existing scripts continue to work.\n\n- The CLI in `navpath/__main__.py` remains unchanged (same flags and help text).\n- All toggles, limits, cost overrides, logging, and requirements inputs behave the same.\n- Human-readable and JSON outputs are byte-for-byte compatible in structure and key names.\n\n#### Acceptance Criteria\n1. WHEN running `python -m navpath --start \"x,y,p\" --goal \"x,y,p\" --json` THEN JSON keys and types match the current implementation.\n2. WHEN using `--json-actions-only` THEN only the `actions` array is emitted with the same per-step shape.\n3. WHEN `--requirements-file` or `--requirements-json` are supplied THEN requirement gating applies identically.\n\n### R3: Deterministic A* behavior\n**User Story:** As a developer, I want deterministic results so that tests and automation are stable.\n\n- Stable priority queue ordering, with the same tie-breakers as `navpath/astar.py`.\n- Deterministic neighbor ordering from the region graph provider.\n\n#### Acceptance Criteria\n1. GIVEN fixed DB and options WHEN run multiple times THEN the same path and action list are returned.\n2. WHEN multiple edges have equal `f,h,g` THEN the same tie-breaking order is observed.\n\n### R4: Limits and cancellation\n**User Story:** As an operator, I want to limit search work to prevent overload.\n\n- Respect `options.max_expansions` and `options.timeout_ms` with the same stop reasons.\n\n#### Acceptance Criteria\n1. IF `max_expansions` exceeded THEN reason SHALL be `\"max-expansions\"`.\n2. IF `timeout_ms` exceeded THEN reason SHALL be `\"timeout\"`.\n\n### R5: Output parity (tiles and actions)\n**User Story:** As a consumer, I want identical path and action output formats so my downstream logic keeps working.\n\n- `PathResult.path` is a list of tile tuples `(x,y,plane)` or `None`.\n- `PathResult.actions` is a list of `ActionStep` with the same fields and chain semantics.\n- Region-to-tile reconstruction uses `region_tiles` to choose concrete tiles deterministically (e.g., along edge border samples or ordered scan by x then y within target region when needed), preserving existing rules for action chain emission.\n\n#### Acceptance Criteria\n1. WHEN a path exists THEN `path` contains tiles and `actions` expand chains with the same per-link metadata keys used by `navpath`.\n2. WHEN no path exists THEN `path` is `null` and reason is one of: `\"unreachable\"|\"timeout\"|\"max-expansions\"|\"tile-not-found\"|\"invalid-input\"`.\n\n### R6: Requirements-aware gating\n**User Story:** As a caller, I want requirement-based availability to work the same way.\n\n- Accept requirements via CLI or `SearchOptions.extras[\"requirements\"]` (list of `{key,value}`), with normalization to `extras[\"requirements_map\"]`.\n- Evaluate requirement rows referenced by region edges (`meta.requirement_id`) using the same integer comparison semantics as in `worldReachableTiles.db`.\n\n#### Acceptance Criteria\n1. GIVEN unmet requirement for an edge THEN that edge SHALL be suppressed from expansion.\n2. GIVEN a mix of unmet and met edges THEN only met edges are considered.\n\n### R7: Cost model and heuristic\n**User Story:** As a tuner, I want consistent cost semantics and overrides.\n\n- Default movement step and node/action costs match `navmesh.db` weight semantics while honoring the same override flags (`--door-cost`, `--lodestone-cost`, etc.).\n- Heuristic remains Chebyshev × step cost on tiles; region-level edges must convert to tile-level distances for admissibility or use per-edge weights that guarantee optimality when reconstructed to tiles.\n\n#### Acceptance Criteria\n1. WHEN no overrides are provided THEN reported `total_cost_ms` equals the sum of chosen edges’ weights.\n2. WHEN overrides are provided THEN they apply consistently per type.\n\n### R8: Logging and metrics parity\n**User Story:** As a maintainer, I want the same concise metrics for observability.\n\n- INFO log includes: `start`, `goal`, `reason`, `expanded`, `path_len`, `total_cost_ms`, `duration_ms`, `req_filtered`, `db` (same keys and order as `navpath/api.py`).\n\n#### Acceptance Criteria\n1. WHEN a search completes THEN a single INFO log line is emitted with the same format.\n\n### R9: Database access and safety\n**User Story:** As a DBA, I want the system to be read-only and resilient.\n\n- All SQLite access is read-only; only `SELECT` queries are executed.\n- The schema consumed is: `nav_regions`, `nav_region_edges`, `region_tiles`, `metadata`.\n- No assumptions about FKs; code must not rely on FK enforcement.\n\n#### Acceptance Criteria\n1. WHEN connected to a valid `navmesh.db` THEN queries succeed with read-only pragmas and no writes.\n2. IF tables are missing or malformed THEN fail gracefully with a clear reason or exception surfaced to the caller.\n\n### R10: Backward compatibility and migration\n**User Story:** As a user, I want to adopt navmesh without breaking integrations.\n\n- The `navpath` package keeps its module layout and CLI; switching DBs changes behavior only in pathfinding back-end.\n- Feature flags and defaults retain their current names and defaults.\n\n#### Acceptance Criteria\n1. WHEN switching between `worldReachableTiles.db` and `navmesh.db` by changing `db_path` THEN the interface and outputs remain consistent.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- **Single Responsibility Principle:** New provider(s) isolate navmesh concerns from existing tile+nodes provider.\n- **Modular Design:** Introduce `NavmeshGraphProvider` and supporting DB layer without altering `astar` or result models.\n- **Clear Interfaces:** Reuse `GraphProvider` and `CostModel` contracts; keep `SearchOptions` unchanged.\n\n### Performance\n- Region graph must reduce expansions vs. tile graph on large areas. Target at least 2× fewer expansions on representative routes.\n- End-to-end latency target: within ±10% of current `navpath` for comparable paths (or faster).\n\n### Security\n- Read-only DB connections; sanitize inputs; no dynamic SQL from user-provided text.\n\n### Reliability\n- Deterministic behavior; defensive handling for missing region tiles; robust chain reconstruction.\n\n### Usability\n- CLI and logging remain unchanged; errors and reasons align with existing values.\n",
  "fileStats": {
    "size": 7840,
    "lines": 134,
    "lastModified": "2025-10-10T20:25:45.335Z"
  },
  "comments": []
}