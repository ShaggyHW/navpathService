{
  "id": "snapshot_1759931313426_0oqqlzalr",
  "approvalId": "approval_1759931313424_5ml5cpmjf",
  "approvalTitle": "Tasks for astar-pathfinding",
  "version": 1,
  "timestamp": "2025-10-08T13:48:33.426Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Tasks Document - astar-pathfinding\n\n- [ ] 1. Create core data models and options\n  - Files: `navpath/path.py`, `navpath/options.py`\n  - Purpose: Define `Tile`, `ActionStep`, `PathResult`, and `SearchOptions` per requirements (actions list included)\n  - _Leverage: `.spec-workflow/specs/astar-pathfinding/requirements.md`, `.spec-workflow/specs/astar-pathfinding/design.md`_\n  - _Requirements: 1, 3, 4, 5_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Python Developer (dataclasses & typing) | Task: Create `ActionStep`, `PathResult` data classes and `SearchOptions` with node-type toggles and limits; ensure JSON-serializable shapes and alignment with the approved schema | Restrictions: Standard library only; follow file structure and naming; keep imports at file top | _Leverage: requirements.md, design.md | _Requirements: 1, 4 | Success: Types compile, fields match schema (path, actions, reason, expanded, cost_ms), options support toggles and limits; docstrings added; ready for import. Also: mark this task as [-] when starting and [x] when done in tasks.md._\n\n- [ ] 2. Implement CostModel\n  - File: `navpath/cost.py`\n  - Purpose: Centralize costs (tile move, door, lodestone, object, ifslot, npc, item) with defaults and overrides\n  - _Leverage: requirements.md §3, design.md_\n  - _Requirements: 3_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Python Developer | Task: Implement `CostModel` with per-edge-type cost lookups and defaults (600ms) and helpers for heuristic (Chebyshev*600) | Restrictions: Keep heuristic admissible; exclude action extras from h | _Leverage: requirements.md §3 | _Requirements: 3 | Success: Unit-importable `CostModel` with deterministic outputs and documented methods; ready for use._\n\n- [ ] 3. Implement SQLite DB access helpers\n  - File: `navpath/db.py`\n  - Purpose: Open SQLite in read-only mode when available, prepare queries for tiles, doors, lodestones, nodes\n  - _Leverage: requirements.md §2, docs/tiles_nodes_schema.md, design.md_\n  - _Requirements: 2, 5, 6_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Python SQLite Engineer | Task: Implement a small DB layer with connection factory, prepared statements, and safe row accessors for tiles and all *_nodes | Restrictions: Read-only; parameterized queries; no full scans | _Leverage: docs/tiles_nodes_schema.md | _Requirements: 2, 5, 6 | Success: Queries are prepared and documented; functions return typed rows; no writes._\n\n- [ ] 4. Implement NodeChainResolver\n  - File: `navpath/nodes.py`\n  - Purpose: Resolve `next_node_type/next_node_id` chains, detect cycles, enforce `max_chain_depth`, compute composite costs and final destination bounds\n  - _Leverage: requirements.md §2.9-2.10, §3.9, design.md_\n  - _Requirements: 2, 3, 5_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Python Developer | Task: Implement `NodeChainResolver` that takes a starting node ref and produces composite action metadata (accumulated cost, final dest bounds), with cycle and depth checks | Restrictions: No recursion without guards; log warnings on invalid chains | _Leverage: requirements.md, design.md | _Requirements: 2, 3, 5 | Success: Unit-importable resolver with clear API and tests stubs._\n\n- [ ] 5. GraphProvider: tiles movement edges\n  - File: `navpath/graph.py`\n  - Purpose: Define `GraphProvider` and implement `SqliteGraphProvider` movement edges from `tiles.allowed_directions`\n  - _Leverage: requirements.md §2.1, design.md_\n  - _Requirements: 1, 2, 6_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Algorithms Engineer | Task: Implement neighbor generation for up to 8-directional moves using allowed_directions bits; cost from `CostModel` | Restrictions: Validate tile existence; no loading full tables | _Leverage: DB helpers; CostModel | _Requirements: 1, 2 | Success: Returns deterministic neighbor list for movement edges only._\n\n- [ ] 6. GraphProvider: door edges\n  - File: `navpath/graph.py`\n  - Purpose: Add bidirectional door edges between inside/outside tiles with costs\n  - _Leverage: requirements.md §2.2, §3.3, design.md_\n  - _Requirements: 2, 3_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Algorithms Engineer | Task: Query door_nodes and add edges with `node_ref` and cost; ensure toggled by options | Restrictions: Deterministic ordering; avoid duplicates | _Leverage: DB helpers | _Requirements: 2, 3 | Success: Door edges appear and pass deterministic ordering._\n\n- [ ] 7. GraphProvider: lodestone teleport edges\n  - File: `navpath/graph.py`\n  - Purpose: Add teleport edges between lodestones with costs\n  - _Leverage: requirements.md §2.3, §3.4, design.md_\n  - _Requirements: 2, 3_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Algorithms Engineer | Task: Add lodestone edges from lodestone_nodes to all destinations; include `node_ref` and cost; toggled by options | Restrictions: Deterministic ordering; efficient queries | _Leverage: DB helpers | _Requirements: 2, 3 | Success: Teleport edges correctly generated._\n\n- [ ] 8. GraphProvider: object/ifslot/npc/item action edges + portal semantics\n  - File: `navpath/graph.py`\n  - Purpose: Add action edges based on origin/destination bounds and composite edges from chains\n  - _Leverage: requirements.md §2.5-2.10, §3.8-3.9, design.md_\n  - _Requirements: 2, 3, 5_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Algorithms Engineer | Task: Implement action edges for object/ifslot/npc/item nodes, use `NodeChainResolver` to produce composite edges, apply portal semantics for bounds | Restrictions: Validate bounds; ignore invalid nodes; deterministic | _Leverage: nodes.py, DB helpers | _Requirements: 2, 3, 5 | Success: Action edges emitted with correct costs and destinations._\n\n- [ ] 9. Implement A* search with deterministic tie-breaking and limits\n  - File: `navpath/astar.py`\n  - Purpose: Implement A* with g/f/h ordering, tie-breaking, `max_expansions`, `timeout_ms`\n  - _Leverage: requirements.md §1, §3.5-3.7, §5.1, design.md_\n  - _Requirements: 1, 3, 5, 6_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Algorithms Engineer | Task: Implement A* using `heapq`; reconstruct parents and store edge metadata for actions; deterministic priority ordering | Restrictions: Do not load entire DB; efficient memory | _Leverage: GraphProvider, CostModel | _Requirements: 1, 3, 5, 6 | Success: Produces optimal path with metrics and respects limits._\n\n- [ ] 10. Implement public API `find_path`\n  - File: `navpath/api.py`\n  - Purpose: Expose `find_path(start, goal, options=None) -> PathResult`; open DB, run search, return result\n  - _Leverage: requirements.md §4, design.md_\n  - _Requirements: 1, 4, 5_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Python Developer | Task: Implement `find_path`, wire DB path overrides, assemble components, and return `PathResult` with path and actions | Restrictions: Parameterize DB path; log summary metrics at INFO | _Leverage: astar.py, graph.py, cost.py, options.py, path.py | _Requirements: 1, 4, 5 | Success: API callable from scripts; deterministic; logs metrics._\n\n- [ ] 11. Implement CLI\n  - File: `navpath/__main__.py`\n  - Purpose: Provide CLI per spec; parse args and print result (JSON or human readable)\n  - _Leverage: requirements.md §4, design.md_\n  - _Requirements: 4_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: Python CLI Developer | Task: Implement CLI with `--start`, `--goal`, `--db`, `--json`, cost/limit flags, and node-type toggles | Restrictions: No external CLI libs; argparse only; stable output formats | _Leverage: api.py | _Requirements: 4 | Success: CLI runs and prints valid JSON when requested._\n\n- [ ] 12. Add targeted unit tests (core)\n  - Files: `tests/test_astar.py`, `tests/test_nodes.py`, `tests/test_graph.py`\n  - Purpose: Validate heuristic, chain resolution, movement and action edges, limits\n  - _Leverage: requirements.md, design.md_\n  - _Requirements: 1, 2, 3, 5, 6_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer | Task: Add tests for Chebyshev heuristic, NodeChainResolver cycles/depth, edges generation, and early termination paths | Restrictions: Use pytest; no DB writes; include fixtures | _Leverage: sqlite fixture db copies | _Requirements: 1,2,3,5,6 | Success: Tests pass locally; cover critical paths._\n\n- [ ] 13. Add integration tests and logging validation\n  - Files: `tests/test_integration.py`\n  - Purpose: Validate end-to-end pathfinding on a small fixture DB and ensure INFO metrics are logged\n  - _Leverage: requirements.md, design.md_\n  - _Requirements: 1, 4, 5, 6_\n  - _Prompt: Implement the task for spec astar-pathfinding, first run spec-workflow-guide to get the workflow guide then implement the task: Role: QA Engineer | Task: Write integration tests that run `find_path` across multiple scenarios (reachable, unreachable, limits) and assert metrics present | Restrictions: Keep runtime small (<1s); isolate fixtures | _Leverage: api.py | _Requirements: 1, 4, 5, 6 | Success: Integration tests pass and verify logs._\n",
  "fileStats": {
    "size": 10136,
    "lines": 93,
    "lastModified": "2025-10-08T13:48:18.899Z"
  },
  "comments": []
}