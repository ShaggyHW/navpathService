{
  "id": "snapshot_1759929356732_wik2gt5mz",
  "approvalId": "approval_1759929198082_ma14bd825",
  "approvalTitle": "Requirements for astar-pathfinding (updated for item_nodes and next_node_type)",
  "version": 2,
  "timestamp": "2025-10-08T13:15:56.732Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\nImplement an A* pathfinding service that returns the least-cost path between a start and end tile using the world graph stored in the SQLite database `worldReachableTiles.db`. The graph consists of:\n- Tile adjacency from `tiles.allowed_directions` (8-directional).\n- Bidirectional door links from `door_nodes` (inside <-> outside).\n- Teleport links between lodestones from `lodestone_nodes`.\n\nNote: The database schema includes additional node tables (`object_nodes`, `ifslot_nodes`, `npc_nodes`, `item_nodes`) and a `next_node_type` field across node tables that now also permits the value `'item'` (see `docs/tiles_nodes_schema.md`). This spec scopes traversal edges strictly to `tiles`, `door_nodes`, and `lodestone_nodes`. Non-traversal node tables and any `next_node_type` chaining are out-of-scope for path computation and do not affect the graph built for A*.\n\nThe output is a sequence of tiles `(x, y, plane)` from start to goal inclusive or a clear indication that no path exists.\n\n## Alignment with Product Vision\n- Provide a reliable, fast, deterministic pathfinding core for navigation features.\n- Reuse existing SQLite world data (`tiles`, `door_nodes`, `lodestone_nodes`) to avoid duplicate sources of truth.\n- Foundation for higher-level route planning and actions execution.\n\n## Requirements\n\n### Requirement 1: Compute path with A*\n**User Story:** As a navigation client, I want to compute the optimal path between two tiles so that I can traverse the world efficiently and deterministically.\n\n#### Acceptance Criteria\n1. WHEN given a valid `start=(x,y,plane)` and `goal=(x,y,plane)` that are connected, THEN the system SHALL return a path (list of `(x,y,plane)`), including both endpoints.\n2. IF `start == goal` THEN the system SHALL return `[start]`.\n3. IF no path exists, THEN the system SHALL return `None` or an empty list and a reason string (e.g., \"unreachable\").\n4. The algorithm SHALL be A* with an admissible, consistent heuristic for 8-directional movement (octile distance) to ensure optimality.\n5. The implementation SHALL be deterministic given identical inputs and configuration (including tie-breaking).\n\n### Requirement 2: Graph modeling from database\n**User Story:** As a developer, I want the graph derived from the SQLite DB so that the pathfinder always reflects the current world data.\n\n#### Acceptance Criteria\n1. The system SHALL read neighbors from `tiles.allowed_directions` in table `tiles(x,y,plane,...)`.\n   - Cardinal moves: north, south, east, west\n   - Diagonals: northeast, northwest, southeast, southwest\n2. The system SHALL add bidirectional edges from `door_nodes` linking `(tile_inside_x, tile_inside_y, tile_inside_plane)` and `(tile_outside_x, tile_outside_y, tile_outside_plane)`.\n3. The system SHALL add teleport edges between any lodestone tile and every other lodestone tile derived from `lodestone_nodes(lodestone, dest_x, dest_y, dest_plane)`.\n4. The system SHALL validate that both start and goal exist in `tiles`. If either does not exist, return an error result (no path, reason=\"tile-not-found\").\n5. The system SHALL ignore non-traversal node tables (`object_nodes`, `ifslot_nodes`, `npc_nodes`, `item_nodes`) and disregard any `next_node_type` chaining (including the `'item'` value now permitted). These do not contribute edges to the graph for A* under this spec.\n\n### Requirement 3: Cost model and heuristic\n**User Story:** As a navigation client, I want realistic costs so paths prefer shorter travel while allowing teleports when beneficial.\n\n#### Acceptance Criteria\n1. All costs SHALL be expressed in milliseconds (ms).\n2. Tile step cost SHALL be fixed at 600 ms per move for both cardinal and diagonal movement.\n3. Door traversal additional cost SHALL be read from `door_nodes.cost` when present; if NULL or missing, default to 600 ms.\n4. Lodestone teleport cost SHALL be read from `lodestone_nodes.cost` when present; if NULL or missing, default to 600 ms.\n5. The heuristic SHALL be Chebyshev distance from current tile to goal multiplied by 600 ms (admissible and consistent for uniform 8-direction step costs).\n6. Heuristic SHALL exclude door/lodestone additional costs to remain admissible.\n7. Tie-breaking SHALL be deterministic (e.g., prefer lower g, then lower h, then lexicographic `(x,y,plane)`).\n\n### Requirement 4: API and I/O\n**User Story:** As a developer, I want a clear API I can call from services or scripts.\n\n#### Acceptance Criteria\n1. Provide a function `find_path(start, goal, options=None) -> PathResult` in Python, where:\n   - `start`, `goal`: `(x:int, y:int, plane:int)`\n   - `options` may override costs and set maximum expansions and timeouts\n   - `PathResult` includes: `path: list[tuple[int,int,int]] | None`, `reason: str | None`, `expanded: int`, `cost_ms: int`\n2. Provide a thin CLI entrypoint: `python -m navpath.astar --start \"x,y,plane\" --goal \"x,y,plane\" [--json]` printing the path or a clear message.\n3. The module SHALL open the DB at `worldReachableTiles.db` by default with an option to pass a different path.\n\n### Requirement 5: Constraints, limits, and safety\n**User Story:** As an operator, I need the service to be robust under large graphs and handle edge cases.\n\n#### Acceptance Criteria\n1. The search SHALL support early termination by:\n   - `max_expansions` (e.g., default 250k)\n   - `timeout_ms` (e.g., default 1000ms)\n   - On termination, return `None` with `reason` (\"max-expansions\" or \"timeout\").\n2. The implementation SHALL guard against missing or malformed DB rows (e.g., missing `allowed_directions`). Missing entries imply no moves from that tile.\n3. The system SHALL log summary metrics at INFO level: expansions, frontier peak, path length, total cost, duration.\n4. The system SHALL validate coordinates are integers within SQLite `tiles` domain and reject invalid input with a friendly message.\n\n### Requirement 6: Performance\n**User Story:** As a user, I want responsive pathfinding for typical path lengths.\n\n#### Acceptance Criteria\n1. For intra-region routes (< 3000 steps), median runtime SHALL be <= 200ms on a modern CPU.\n2. Memory footprint per search SHALL be O(V) with bounded priority queue growth.\n3. The system SHALL avoid loading the entire DB into memory; use prepared statements/caching for neighbor lookups where appropriate.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Single Responsibility: DB access, graph expansion, heuristic/costs, and API/CLI separated into modules.\n- Clear Interfaces: `GraphProvider` for neighbor and edge lookups; `AStarSearch` for algorithm; `CostModel` for weights.\n- Dependency Management: Standard library + `sqlite3`; no heavy dependencies required.\n\n### Security\n- Read-only DB access; no writes to `worldReachableTiles.db`.\n- Validate inputs; avoid SQL injection (use parameterized queries only).\n\n### Reliability\n- Deterministic outputs; unit tests for edge cases and typical paths.\n- Fallback behaviors on missing data (skip edges, mark unreachable).\n\n### Usability\n- Path results serialize to JSON for CLI/API.\n- Clear error reasons and metrics for observability.\n\n## Open Questions\n- Should lodestone teleport cost be different per destination or dynamic (e.g., based on travel time)? Default is a fixed cost (25.0).\n- Should diagonal moves be permitted everywhere `allowed_directions` includes them, or require both adjacent cardinals unblocked? Default: trust `allowed_directions`.\n- Any maximum path length or step cap beyond `max_expansions`?\n",
  "fileStats": {
    "size": 7507,
    "lines": 108,
    "lastModified": "2025-10-08T13:12:25.184Z"
  },
  "comments": []
}