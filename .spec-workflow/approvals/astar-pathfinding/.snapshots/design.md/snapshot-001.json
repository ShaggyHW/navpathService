{
  "id": "snapshot_1759930295733_2p674uqs7",
  "approvalId": "approval_1759930295731_u9vnydkua",
  "approvalTitle": "Design for astar-pathfinding (A* with nodes + actions)",
  "version": 1,
  "timestamp": "2025-10-08T13:31:35.733Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\nImplement an A* pathfinding service that finds the least-cost route between two tiles using data from `worldReachableTiles.db`. The graph includes:\n- Tile adjacency from `tiles.allowed_directions` (8-directional)\n- Door links from `door_nodes`\n- Teleport links from `lodestone_nodes`\n- Action edges from `object_nodes`, `ifslot_nodes`, `npc_nodes`, `item_nodes`\n- Mandatory `next_node` chaining when present, modeled as a single composite action\n\nOutputs include both a tile `path` and an ordered `actions` list of steps (movement and node interactions) required to traverse the route.\n\n## Steering Document Alignment\nNo dedicated steering docs are provided. This design follows common Python service patterns:\n- Clear module boundaries (data access, graph expansion, algorithm, API/CLI)\n- Deterministic behavior and observability (metrics, logging)\n- SQLite read-only, parameterized queries\n\n## Code Reuse Analysis\n- Existing code: none directly reusable for A* in this repo, but we will reuse standard library `sqlite3`, `heapq`, `dataclasses`, `typing`, `time`, `logging`, and `functools.lru_cache`.\n- Database assets: `worldReachableTiles.db` is the single source of truth.\n\n### Integration Points\n- SQLite database at the project root: `worldReachableTiles.db`\n- Optional future service/API integration can wrap the provided Python API/CLI\n\n## Architecture\n\n### Modules (proposed package: `navpath/`)\n- `db.py`\n  - SQLite connection management (read-only mode where available)\n  - Prepared statements for tiles, doors, lodestones, and node tables\n  - Row parsing helpers\n- `nodes.py`\n  - Data models for node references and bounds\n  - `NodeChainResolver` to resolve `next_node` chains, detect cycles, enforce `max_chain_depth`\n- `graph.py`\n  - `GraphProvider` interface\n  - `SqliteGraphProvider` implementation that yields neighbors (movement and action edges)\n  - Origin/destination bounds handling for node edges\n- `cost.py`\n  - `CostModel` that provides step costs (tile, door, lodestone, object, ifslot, npc, item)\n- `astar.py`\n  - `AStarSearch` implementing A* with octile (Chebyshev) heuristic*600ms and deterministic tie-breaking\n  - Early termination: `max_expansions`, `timeout_ms`\n- `path.py`\n  - Data classes: `ActionStep`, `PathResult`\n  - `PathReconstructor` to build both `path` and `actions` from predecessor map and edge metadata\n- `options.py`\n  - `SearchOptions` dataclass (`use_doors/lodestones/objects/ifslots/npcs/items`, costs, limits)\n- `__main__.py`\n  - CLI entrypoint per requirements\n\n```mermaid\nflowchart TD\n    CLI[CLI (__main__.py)] --> API[find_path]\n    API --> ASTAR[AStarSearch]\n    ASTAR --> GRAPH[SqliteGraphProvider]\n    GRAPH --> DB[SQLite (db.py)]\n    GRAPH --> CHAIN[NodeChainResolver]\n    ASTAR --> COST[CostModel]\n    ASTAR --> RECON[PathReconstructor]\n    RECON --> OUT[PathResult {path, actions, cost_ms, expanded}]\n```\n\n## Components and Interfaces\n\n### GraphProvider (graph.py)\n- `neighbors(tile: Tuple[int,int,int], goal: Tuple[int,int,int], opt: SearchOptions) -> Iterable[Edge]`\n  - Produces `Edge` with fields: `from`, `to`, `type` (move|door|lodestone|object|ifslot|npc|item), `cost_ms`, optional `node_ref` and `chain_meta`.\n- Sources:\n  - Tiles: decode `allowed_directions` bits, emit up to 8 moves at cost 600ms each.\n  - Door: bidirectional edges between inside/outside; cost from `door_nodes.cost` (default 600).\n  - Lodestone: edges to other lodestone destinations; cost from `lodestone_nodes.cost` (default 600).\n  - Object/Ifslot/NPC/Item: action edges to destination bounds if present; portal semantics when origin and destination are bounds.\n  - `next_node` chaining: resolve via `NodeChainResolver` and emit a single composite edge with accumulated cost and final destination.\n\n### NodeChainResolver (nodes.py)\n- Inputs: starting node (type,id), DB access, `max_chain_depth` (default 8)\n- Follows `next_node_type/next_node_id` until terminal\n- Detects cycles (visited set), depth overflow\n- Aggregates total cost and final destination bounds; produces composite edge metadata\n\n### CostModel (cost.py)\n- Methods for each edge type cost with defaults at 600ms when null/absent\n- Heuristic: Chebyshev distance * 600ms (exclude door/lodestone/action extras to remain admissible)\n\n### AStarSearch (astar.py)\n- Priority queue with tuple `(f, g, h, tiebreak_id, node)` for deterministic ordering\n- Tracks `g`, parents, and `edge_meta` used to reconstruct actions\n- Early termination: `max_expansions`, `timeout_ms`\n\n### PathReconstructor (path.py)\n- Builds tile `path` by backtracking parents\n- Builds `actions` by emitting a step per traversed edge using stored `edge_meta`\n- `ActionStep` schema per requirements\n\n### API (navpath.find_path)\n- Signature: `find_path(start, goal, options=None) -> PathResult`\n- Opens DB (path overridable); constructs provider/search; returns `PathResult`\n\n### CLI (__main__.py)\n- Args: `--start`, `--goal`, `--db`, `--json`, cost/limit flags, node-type toggles\n- Prints human-readable or JSON `PathResult`\n\n## Data Models\n\n```python\n# path.py\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Tuple, Literal\n\nTile = Tuple[int,int,int]\nStepType = Literal[\"move\",\"door\",\"lodestone\",\"object\",\"ifslot\",\"npc\",\"item\"]\n\n@dataclass\nclass NodeRef:\n    type: str\n    id: int\n\n@dataclass\nclass ActionStep:\n    type: StepType\n    from_tile: Tile\n    to_tile: Tile\n    cost_ms: int\n    node: Optional[NodeRef] = None\n\n@dataclass\nclass PathResult:\n    path: Optional[List[Tile]]\n    actions: List[ActionStep]\n    reason: Optional[str]\n    expanded: int\n    cost_ms: int\n```\n\n## Error Handling\n- Missing tiles for start/goal: return `path=None`, `actions=[]`, `reason=\"tile-not-found\"`\n- Chain cycles or `max_chain_depth` exceeded: edge ignored with logged warning\n- Invalid bounds (min>max): node ignored with logged warning\n- Timeout/expansion cap: return `reason=\"timeout\"` or `\"max-expansions\"`\n\n## Performance & Caching\n- Use prepared statements; avoid full-table scans\n- LRU cache neighbor computations for hot tiles (bound by opt limits)\n- Keep memory O(V), priority queue growth bounded by expansions\n\n## Logging & Metrics\n- INFO summary: expansions, frontier peak, path length, total cost, duration\n- DEBUG for edge generation and chain resolution (guarded by flags)\n\n## Testing Strategy\n- Unit tests:\n  - Heuristic correctness and consistency\n  - Door/lodestone/action edge creation\n  - Chain resolution including cycles/depth-limits\n  - Path reconstruction with actions\n- Integration tests:\n  - End-to-end queries on small fixture DBs\n  - Limits: timeout and max_expansions behavior\n- CLI tests:\n  - JSON output schema validation\n",
  "fileStats": {
    "size": 6669,
    "lines": 164,
    "lastModified": "2025-10-08T13:31:17.354Z"
  },
  "comments": []
}