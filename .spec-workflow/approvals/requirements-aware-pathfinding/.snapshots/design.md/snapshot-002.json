{
  "id": "snapshot_1759967920900_2pk716sbs",
  "approvalId": "approval_1759967831123_y1yu0zp7w",
  "approvalTitle": "Design: Requirements-aware Pathfinding",
  "version": 2,
  "timestamp": "2025-10-08T23:58:40.900Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design: Requirements-aware Pathfinding\n\n## Overview\n\nImplement requirement-based gating across all node types (door, lodestone, object, ifslot, npc, item). Nodes referencing `requirements(id)` via `requirement_id` are eligible only when the requirement evaluates true against a per-request context supplied by callers. The context is a JSON array of `{key, value}` objects (values are integers; CLI coerces booleans to 1/0). Gating applies to single nodes and to every link in `next_node` chains.\n\nThis design introduces:\n- CLI flags to ingest the requirements array and coerce booleans.\n- A lightweight `RequirementsEvaluator` utility to evaluate a requirement row against the request context.\n- Minimal DB access additions to fetch requirement rows and expose `requirement_id` in node row models.\n- Graph-layer gating performed early, before sorting/ordering, and integrated with chain resolution.\n- Metrics to count requirement-filtered nodes.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Deterministic behavior preserved: gating is applied prior to neighbor ordering and uses stable sorts already present in `graph.py`.\n- Single-responsibility: parsing in CLI, evaluation in dedicated utility, integration in graph provider.\n- Read-only, parameterized SQL maintained.\n\n### Project Structure (structure.md)\n- Keep additions minimal and localized: CLI parsing (`navpath/__main__.py`), small DB helper (`navpath/db.py`), evaluator utility (`navpath/requirements.py`), integration in graph (`navpath/graph.py`) and chain resolver (`navpath/nodes.py`).\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`SearchOptions.extras`**: Vehicle to pass the requirements list from CLI/API into the graph.\n- **`SqliteGraphProvider` in `navpath/graph.py`**: Central place to integrate gating for neighbor generation and for action chain edges.\n- **`NodeChainResolver` in `navpath/nodes.py`**: Integrate gating on each chain link.\n- **`CostModel`** and A*: unchanged; they consume the already-gated neighbors.\n\n### Integration Points\n- **CLI (`navpath/__main__.py`)**: Add flags, parse JSON array, coerce booleans, validate integers, place into `SearchOptions.extras[\"requirements\"]`.\n- **API (`navpath/api.py`)**: No signature change. Ensure `options.extras` is a dict; pass through. Optionally normalize list to a dict cache in extras for efficiency.\n- **DB (`navpath/db.py`)**: Add `requirement_id` to node row models and SELECTs; add `fetch_requirement(req_id)`.\n- **Graph (`navpath/graph.py`)**: Before yielding any edge, gate by requirement using evaluator and the request context.\n- **Nodes (`navpath/nodes.py`)**: In chain resolution, gate each link; fail the chain if any link fails.\n\n## Architecture\n\n```mermaid\nflowchart TD\n    CLI[CLI parse requirements] --> OPTS[SearchOptions.extras]\n    API[find_path] --> OPTS\n    OPTS --> G[SqliteGraphProvider]\n    DB[(SQLite)] --> G\n    G --> EVAL[RequirementsEvaluator]\n    G --> RES[NodeChainResolver]\n    RES --> EVAL\n    G --> ASTAR[A*]\n    ASTAR --> LOG[API summary logging]\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Evaluator is isolated; DB helpers remain read-only; CLI handles only parsing/coercion.\n- **Component Isolation**: Gating logic is a small API used by both graph and chain resolver.\n- **Service Layer Separation**: DB access stays in `db.py`; no SQL in graph beyond existing queries.\n\n## Components and Interfaces\n\n### CLI changes (`navpath/__main__.py`)\n- **Purpose:** Ingest requirement context as a JSON array and coerce booleans.\n- **Interfaces:**\n  - New args: `--requirements-file PATH`, `--requirements-json JSON_STRING`.\n  - Behavior:\n    - Load array from file and/or parse string; merge with last-wins by `key`.\n    - Coerce boolean literals `true`/`false` to `1`/`0` before validation.\n    - Validate each item: must be object with `key` (string) and `value` (int after coercion). Reject on invalid with clear error and non-zero exit.\n  - Place final array into `options.extras[\"requirements\"]`.\n\n### API (`navpath/api.py`)\n- **Purpose:** Pass through requirements context and include metrics in logs.\n- **Interfaces:**\n  - No signature change; `SearchOptions.extras[\"requirements\"]` is the carrier.\n  - Normalization (optional): on entry, if extras list is present, build an internal dict `extras[\"requirements_map\"]: Dict[str,int]` for O(1) lookups. Retain the original list for API compatibility.\n  - Logging: include `req_filtered` count from graph provider in the INFO summary line. If not available, default to 0.\n\n### DB helpers (`navpath/db.py`)\n- **Purpose:** Supply `requirement_id` for nodes and fetch requirement rows.\n- **Changes:**\n  - Extend dataclasses to include `requirement_id: Optional[int]` for: `DoorNodeRow`, `LodestoneNodeRow`, `ObjectNodeRow`, `IfslotNodeRow`, `NpcNodeRow`, `ItemNodeRow`.\n  - Update SELECT lists to include `requirement_id` columns for corresponding tables.\n  - New dataclass:\n    ```python\n    @dataclass(slots=True)\n    class RequirementRow:\n        id: int\n        metaInfo: Optional[str]\n        key: str\n        value: int\n        comparison: str\n    ```\n  - New method:\n    ```python\n    def fetch_requirement(self, req_id: int) -> Optional[RequirementRow]:\n        row = conn.execute(\n            \"SELECT id, metaInfo, key, value, comparison FROM requirements WHERE id = ?\",\n            (req_id,),\n        ).fetchone()\n        return None if row is None else RequirementRow(...)\n    ```\n\n### Requirements evaluator (`navpath/requirements.py`)\n- **Purpose:** Evaluate a single requirement against the context.\n- **Interface:**\n  ```python\n  def evaluate_requirement(req: RequirementRow, ctx_map: Dict[str, int]) -> bool:\n      # Missing key => False (not available)\n      v = ctx_map.get(req.key)\n      if v is None:\n          return False\n      rv = int(req.value)\n      op = req.comparison\n      if op == \"=\": return v == rv\n      if op == \"!=\": return v != rv\n      if op == \"<\": return v < rv\n      if op == \"<=\": return v <= rv\n      if op == \">\": return v > rv\n      if op == \">=\": return v >= rv\n      return False  # unknown operators are treated as unmet\n  ```\n- **Notes:** Integers only. Deterministic semantics.\n\n### Graph provider (`navpath/graph.py`)\n- **Purpose:** Gate neighbors early, count filtered nodes, and keep deterministic ordering.\n- **Changes:**\n  - On construction, accept `options.extras` and build `ctx_map` from `extras[\"requirements\"]` (list) or `extras.get(\"requirements_map\")` if normalized by API.\n  - Maintain `self.req_filtered_count: int = 0`.\n  - For each candidate neighbor/edge sourced from any node row:\n    - If `row.requirement_id` is not None: fetch requirement row (with a small LRU cache in-memory keyed by id), evaluate with `ctx_map`.\n    - If evaluation is False: increment `req_filtered_count` and skip emitting the edge.\n  - Preserve existing deterministic ordering and only sort/emit after gating.\n\n### Node chain resolver (`navpath/nodes.py`)\n- **Purpose:** Integrate gating into `next_node` chain resolution.\n- **Changes:**\n  - Before processing a link, gate it using the same evaluator and `ctx_map`.\n  - If any link in the chain fails gating, abort resolution for that head and report as not resolvable.\n  - Existing cycle/missing bounds checks remain unchanged.\n\n## Data Models\n\n### RequirementRow (new)\n```\n- id: int\n- metaInfo: Optional[str]\n- key: str\n- value: int\n- comparison: str  # one of = != < <= > >=\n```\n\n### Extras additions (no schema change)\n```\nSearchOptions.extras[\"requirements\"]: List[{key: str, value: int}]\nSearchOptions.extras[\"requirements_map\"]: Dict[str,int]  # optional normalized cache\n```\n\n## Error Handling\n\n### Error Scenarios\n1. **Invalid requirements JSON (CLI)**\n   - **Handling:** Print clear error; exit non-zero. No partial execution.\n   - **User Impact:** Command fails fast with message indicating offending element or parse error.\n\n2. **Non-integer value after coercion (CLI)**\n   - **Handling:** Print error, non-zero exit.\n   - **User Impact:** Command fails; instruct to use ints (booleans as 1/0).\n\n3. **Unknown operator in DB**\n   - **Handling:** Evaluator returns False, effectively gating out the node.\n   - **User Impact:** Node is ignored; deterministic behavior preserved.\n\n4. **Requirement row missing**\n   - **Handling:** Treat as unmet (False) and skip; log DEBUG once per id.\n   - **User Impact:** Node ignored.\n\n## Testing Strategy\n\n### Unit Testing\n- Evaluator: all operators with boundary conditions.\n- CLI parsing: file/string sources, boolean coercion, merge semantics, invalid cases.\n\n### Integration Testing\n- Graph gating: craft in-memory SQLite test DB with nodes referencing requirements; verify edges emitted only when satisfied.\n- Chain gating: multi-link chains where one link fails; ensure chain excluded.\n\n### End-to-End Testing\n- CLI to `find_path` on test DB: confirm different contexts produce/skip certain paths; verify `req_filtered` count in logs.\n\n## Implementation Notes\n- Caching: Cache fetched requirement rows by id in graph to minimize queries.\n- Performance: Convert requirements list to a dict once; evaluator is simple integer comparisons.\n- Logging: Add `req_filtered` to API summary: `... req_filtered=%d ...`.\n",
  "fileStats": {
    "size": 9238,
    "lines": 194,
    "lastModified": "2025-10-08T23:56:54.965Z"
  },
  "comments": []
}