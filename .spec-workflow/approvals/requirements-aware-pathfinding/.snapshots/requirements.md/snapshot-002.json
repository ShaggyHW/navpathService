{
  "id": "snapshot_1759967336148_ijtkpkqta",
  "approvalId": "approval_1759967290585_0dhb0n72d",
  "approvalTitle": "Requirements v2: Requirements-aware Pathfinding (dynamic {key,value} JSON array)",
  "version": 2,
  "timestamp": "2025-10-08T23:48:56.148Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements: Requirements-aware Pathfinding\n\n## Introduction\n\nAdd requirements-aware gating to pathfinding so that nodes in the SQLite world graph are only considered if their referenced requirement is satisfied by caller-supplied data. Each node table may reference `requirements(id)` via a `requirement_id` column. When a node has a `requirement_id`, the search must consult a per-request \"requirements context\" and ignore the node if the requirement is not met or if there is no data provided for that requirement key.\n\nCanonical requirements context format is a JSON array of dynamic key/value pairs:\n\n```json\n[\n  { \"key\": \"hasKey\", \"value\": 1 },\n  { \"key\": \"questStage\", \"value\": 23 },\n  { \"key\": \"spellUnlocked\", \"value\": true }\n]\n```\n\nThis array is intentionally flexible to support an ever-expanding set of requirement keys. The comparison operator is stored in the DB in `requirements.comparison` and is used during evaluation.\n\nValue:\n- Ensures paths do not use actions/teleports/doors that are unavailable to the player/client context.\n- Provides deterministic, explicit filtering consistent with A*’s optimality and stable ordering.\n\n## Alignment with Product Vision\n\n- Reliability and correctness: Do not produce infeasible paths.\n- Extensibility: Dynamic JSON format allows new requirement keys without code changes to input shape.\n- Determinism: Filtering happens before neighbor ordering, preserving stable expansion order.\n\n## Background and Current State\n\n- Public API `navpath.api.find_path(start, goal, options=None, db_path=None)` orchestrates DB, graph, and A*.\n- CLI `python -m navpath` supports toggles, limits, and outputs, but currently does not ingest any requirement context.\n- Schema (`docs/tiles_nodes_schema.md`) lists node tables with `requirement_id` referencing `requirements(id)`. The `requirements` table has columns: `id`, `metaInfo` (TEXT), `key` (TEXT), `value` (INTEGER), `comparison` (TEXT). Possible `comparison` operators include `<`, `<=`, `=`, `>=`, `>` and `!=`.\n- Node tables: `door_nodes`, `lodestone_nodes`, `object_nodes`, `ifslot_nodes`, `npc_nodes`, `item_nodes`.\n\n## Requirements\n\n### R1. Node gating based on requirement context\n\n- IF a node row has a non-NULL `requirement_id`, THEN the node SHALL be considered eligible only if the requirement evaluates to true against the caller-supplied requirement context.\n- IF there is no entry for the requirement `key` in the provided context JSON array, THEN the requirement SHALL be treated as not available and the node SHALL be ignored.\n- Applies to all node sources, including chain links resolved via `next_node_type`/`next_node_id`. A single unmet requirement anywhere in the chain SHALL cause the entire action chain to be excluded.\n\nAcceptance Criteria\n1. WHEN pathfinding runs with a requirement context that satisfies a node’s requirement, THEN that node MAY be used in the returned path (subject to A* search).\n2. WHEN a node has a `requirement_id` and the requirement is not satisfied, THEN that node SHALL not appear in any explored neighbor set and SHALL not contribute to actions.\n3. WHEN a node has a `requirement_id` and the requirement `key` is absent from the JSON array, THEN that node SHALL be ignored.\n\n### R2. Requirement evaluation semantics\n\n- Evaluation compares the provided context value for `key` against the requirement row’s `value` using the `comparison` operator from the DB.\n- Supported operators: `=`, `!=`, `<`, `<=`, `>`, `>=`.\n- Type handling:\n  - Numeric comparison for `<`, `<=`, `>`, `>=` (context value and requirement value MUST be numeric). If non-numeric, evaluation SHALL be false.\n  - Equality operators `=` and `!=` SHALL support numeric, boolean, and string values. If types differ, attempt string comparison by converting both to strings.\n\nAcceptance Criteria\n1. GIVEN requirement row `(key=\"hasKey\", value=1, comparison=\"=\")` and context `[{\"key\":\"hasKey\",\"value\":1}]`, THEN evaluation is true; `[{\"key\":\"hasKey\",\"value\":0}]` is false; `[]` is false.\n2. GIVEN row `(key=\"questStage\", value=30, comparison=\">=\")` and context `[{\"key\":\"questStage\",\"value\":35}]`, THEN evaluation is true; `[{\"key\":\"questStage\",\"value\":29}]` is false; `[]` is false.\n\n### R3. API support for requirement context\n\n- `find_path()` SHALL accept requirement context via `SearchOptions.extras[\"requirements\"]` as a list of `{\"key\": str, \"value\": Any}` pairs.\n- If the extras mapping is missing or not a list, behavior SHALL be as if the list is empty.\n- No signature change to `find_path()` required; API remains backward compatible.\n\nAcceptance Criteria\n1. WHEN `find_path()` is called with `options.extras = {\"requirements\": [{\"key\":\"hasKey\",\"value\":1}]}`, THEN the graph layer SHALL gate nodes according to that list.\n2. WHEN `find_path()` is called without any `requirements` extras, THEN nodes with non-NULL `requirement_id` SHALL be ignored.\n\n### R4. CLI ingestion of requirement context JSON\n\n- The CLI SHALL accept requirement context via one of the following inputs:\n  - `--requirements-file PATH` pointing to a JSON file containing an array of `{key,value}` objects.\n  - `--requirements-json JSON_STRING` directly on the command line containing the same array shape.\n- JSON shape (canonical) is a flat array of key/value objects:\n\n```json\n[\n  { \"key\": \"hasKey\", \"value\": 1 },\n  { \"key\": \"questStage\", \"value\": 23 }\n]\n```\n\n- If both flags are provided, `--requirements-json` SHALL override pairs from `--requirements-file` on a per-key last-wins basis.\n- The parsed array SHALL be placed into `SearchOptions.extras[\"requirements\"]` for consumption by the graph.\n- Invalid JSON SHALL produce a clear CLI parse error and exit with non-zero status.\n\nAcceptance Criteria\n1. WHEN `--requirements-file` is provided and readable, THEN its JSON array is loaded and used for gating.\n2. WHEN `--requirements-json` is provided, THEN it is parsed and used (overriding any overlapping keys from file).\n3. WHEN neither is provided, THEN the effective list is empty and nodes with requirements are ignored.\n4. Invalid JSON results in a non-zero exit and a clear error message.\n\n### R5. Logging and metrics\n\n- `find_path()` summary logging SHALL include a count of nodes/edges filtered due to unmet requirements (aggregate count), exposed in the `INFO` summary line or as a separate DEBUG detail.\n- No change to output JSON shape for `PathResult` is required in this phase.\n\nAcceptance Criteria\n1. WHEN gating excludes nodes, THEN a counter is emitted in logs (e.g., `req_filtered=123`).\n\n### R6. Determinism and performance\n\n- Determinism SHALL be preserved: the presence of gating must not introduce nondeterministic ordering.\n- Performance impact SHALL be minimal; evaluation SHOULD occur as early as practical (preferably within SQL WHERE clauses or immediately after row fetch, before neighbor sorting).\n\nAcceptance Criteria\n1. Benchmark on representative queries shows no more than a small constant-factor overhead under gating (implementation to validate in design).\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Introduce a focused requirement evaluation utility (e.g., `RequirementsEvaluator`) to keep graph logic clean.\n- Centralize requirement parsing and operator handling.\n- Integrate gating into both simple node expansions and chain resolution.\n\n### Security\n- CLI must treat requirement inputs as untrusted JSON; do not execute code. Validate types defensively.\n\n### Reliability\n- Failing to parse requirements SHALL fail fast on CLI with a clear message; API callers can validate before passing.\n\n### Usability\n- Provide concise README updates showing how to pass requirement context through CLI and API.\n\n## Out of Scope (for this spec)\n- No schema changes. We consume the existing `requirements` table.\n- No changes to `PathResult` schema.\n- No per-node custom error messages for unmet requirements.\n\n## Open Questions\n- Should we support both array and object map inputs for convenience (array remains canonical)?\n- Any additional operators beyond `= != < <= > >=`?\n\n## References\n- API: `navpath/api.py` `find_path()`\n- CLI: `navpath/__main__.py`\n- Options: `navpath/options.py` `SearchOptions`\n- Schema: `docs/tiles_nodes_schema.md` (see `requirements` and `*_nodes.requirement_id`)\n",
  "fileStats": {
    "size": 8257,
    "lines": 141,
    "lastModified": "2025-10-08T23:47:58.448Z"
  },
  "comments": []
}