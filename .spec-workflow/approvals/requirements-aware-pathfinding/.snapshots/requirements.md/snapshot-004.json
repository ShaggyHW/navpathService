{
  "id": "snapshot_1759967635870_eesv108xm",
  "approvalId": "approval_1759967600546_flgrahnua",
  "approvalTitle": "Requirements v4: Requirements-aware Pathfinding (CLI boolean coercion; fixed operator set)",
  "version": 4,
  "timestamp": "2025-10-08T23:53:55.870Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements: Requirements-aware Pathfinding\n\n## Introduction\n\nAdd requirements-aware gating to pathfinding so that nodes in the SQLite world graph are only considered if their referenced requirement is satisfied by caller-supplied data. Each node table may reference `requirements(id)` via a `requirement_id` column. When a node has a `requirement_id`, the search must consult a per-request \"requirements context\" and ignore the node if the requirement is not met or if there is no data provided for that requirement key.\n\nCanonical requirements context format is a JSON array of dynamic key/value pairs, where values are integers (booleans accepted by CLI and coerced to 0/1):\n\n```json\n[\n  { \"key\": \"hasKey\", \"value\": 1 },\n  { \"key\": \"questStage\", \"value\": 23 },\n  { \"key\": \"spellUnlocked\", \"value\": 0 }\n]\n```\n\nThe comparison operator is stored in the DB in `requirements.comparison` and is used during evaluation. This array format is flexible for an ever-expanding set of requirement keys.\n\nValue:\n- Ensures paths do not use actions/teleports/doors that are unavailable to the player/client context.\n- Provides deterministic, explicit filtering consistent with A*’s optimality and stable ordering.\n\n## Alignment with Product Vision\n\n- Reliability and correctness: Do not produce infeasible paths.\n- Extensibility: Dynamic JSON format allows new requirement keys without changing the input shape.\n- Determinism: Filtering happens before neighbor ordering, preserving stable expansion order.\n\n## Background and Current State\n\n- Public API `navpath.api.find_path(start, goal, options=None, db_path=None)` orchestrates DB, graph, and A*.\n- CLI `python -m navpath` supports toggles, limits, and outputs, but currently does not ingest any requirement context.\n- Schema (`docs/tiles_nodes_schema.md`) lists node tables with `requirement_id` referencing `requirements(id)`. The `requirements` table has columns: `id`, `metaInfo` (TEXT), `key` (TEXT), `value` (INTEGER), `comparison` (TEXT).\n- Node tables: `door_nodes`, `lodestone_nodes`, `object_nodes`, `ifslot_nodes`, `npc_nodes`, `item_nodes`.\n\n## Requirements\n\n### R1. Node gating based on requirement context\n\n- IF a node row has a non-NULL `requirement_id`, THEN the node SHALL be considered eligible only if the requirement evaluates to true against the caller-supplied requirement context.\n- IF there is no entry for the requirement `key` in the provided context JSON array, THEN the requirement SHALL be treated as not available and the node SHALL be ignored.\n- Applies to all node sources, including chain links resolved via `next_node_type`/`next_node_id`. A single unmet requirement anywhere in the chain SHALL cause the entire action chain to be excluded.\n\nAcceptance Criteria\n1. WHEN pathfinding runs with a requirement context that satisfies a node’s requirement, THEN that node MAY be used in the returned path (subject to A* search).\n2. WHEN a node has a `requirement_id` and the requirement is not satisfied, THEN that node SHALL not appear in any explored neighbor set and SHALL not contribute to actions.\n3. WHEN a node has a `requirement_id` and the requirement `key` is absent from the JSON array, THEN that node SHALL be ignored.\n\n### R2. Requirement evaluation semantics\n\n- All evaluations are integer-based: the provided context `value` (integer) is compared to the requirement row’s `value` (INTEGER) using the `comparison` operator from the DB.\n- Supported operators (limited to): `=`, `!=`, `<`, `<=`, `>`, `>=`.\n- Type handling and validation:\n  - CLI SHALL accept boolean literals `true`/`false` and coerce them to `1`/`0` respectively before validation.\n  - After coercion, the context `value` MUST be an integer.\n  - Non-integer `value` inputs (after coercion) SHALL be rejected at CLI parse-time with a clear error. API callers SHOULD validate before passing.\n\nAcceptance Criteria\n1. GIVEN row `(key=\"hasKey\", value=1, comparison=\"=\")` and context `[{\"key\":\"hasKey\",\"value\":1}]`, THEN evaluation is true; `[{\"key\":\"hasKey\",\"value\":0}]` is false; `[]` is false.\n2. GIVEN row `(key=\"questStage\", value=30, comparison=\">=\")` and context `[{\"key\":\"questStage\",\"value\":35}]`, THEN evaluation is true; `[{\"key\":\"questStage\",\"value\":29}]` is false; `[]` is false.\n\n### R3. API support for requirement context\n\n- `find_path()` SHALL accept requirement context via `SearchOptions.extras[\"requirements\"]` as a list of `{ \"key\": str, \"value\": int }` pairs.\n- If `extras[\"requirements\"]` is missing or not a list, behavior SHALL be as if the list is empty.\n- No signature change to `find_path()` required; API remains backward compatible.\n\nAcceptance Criteria\n1. WHEN `find_path()` is called with `options.extras = {\"requirements\": [{\"key\":\"hasKey\",\"value\":1}]}`, THEN the graph layer SHALL gate nodes according to that list.\n2. WHEN `find_path()` is called without any `requirements` extras, THEN nodes with non-NULL `requirement_id` SHALL be ignored.\n\n### R4. CLI ingestion of requirement context JSON\n\n- The CLI SHALL accept requirement context via one of the following inputs:\n  - `--requirements-file PATH` pointing to a JSON file containing an array of `{key,value}` objects.\n  - `--requirements-json JSON_STRING` directly on the command line containing the same array shape.\n- JSON shape (canonical):\n\n```json\n[\n  { \"key\": \"hasKey\", \"value\": 1 },\n  { \"key\": \"questStage\", \"value\": 23 },\n  { \"key\": \"spellUnlocked\", \"value\": 0 }\n]\n```\n\n- Boolean convenience: CLI SHALL coerce `true`/`false` to `1`/`0` prior to validation.\n- If both flags are provided, `--requirements-json` SHALL override pairs from `--requirements-file` on a per-key last-wins basis.\n- The parsed array SHALL be placed into `SearchOptions.extras[\"requirements\"]` for consumption by the graph.\n- Invalid JSON or non-integer `value` (after coercion) SHALL produce a clear CLI parse error and exit with non-zero status.\n\nAcceptance Criteria\n1. WHEN `--requirements-file` is provided and readable, THEN its JSON array is loaded and used for gating.\n2. WHEN `--requirements-json` is provided, THEN it is parsed and used (overriding any overlapping keys from file).\n3. WHEN neither is provided, THEN the effective list is empty and nodes with requirements are ignored.\n4. Invalid JSON or non-integer values (after coercion) result in a non-zero exit and a clear error message.\n\n### R5. Logging and metrics\n\n- `find_path()` summary logging SHALL include a count of nodes/edges filtered due to unmet requirements (aggregate count), exposed in the `INFO` summary line or as a separate DEBUG detail.\n- No change to output JSON shape for `PathResult` is required in this phase.\n\nAcceptance Criteria\n1. WHEN gating excludes nodes, THEN a counter is emitted in logs (e.g., `req_filtered=123`).\n\n### R6. Determinism and performance\n\n- Determinism SHALL be preserved: the presence of gating must not introduce nondeterministic ordering.\n- Performance impact SHALL be minimal; evaluation SHOULD occur as early as practical (preferably within SQL WHERE clauses or immediately after row fetch, before neighbor sorting).\n\nAcceptance Criteria\n1. Benchmark on representative queries shows no more than a small constant-factor overhead under gating (implementation to validate in design).\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Introduce a focused requirement evaluation utility (e.g., `RequirementsEvaluator`) to keep graph logic clean.\n- Centralize requirement parsing and operator handling.\n- Integrate gating into both simple node expansions and chain resolution.\n\n### Security\n- CLI must treat requirement inputs as untrusted JSON; do not execute code. Validate types defensively.\n\n### Reliability\n- Failing to parse requirements SHALL fail fast on CLI with a clear message; API callers can validate before passing.\n\n### Usability\n- Provide concise README updates showing how to pass requirement context through CLI and API.\n\n## Out of Scope (for this spec)\n- No schema changes. We consume the existing `requirements` table.\n- No changes to `PathResult` schema.\n- No per-node custom error messages for unmet requirements.\n\n## Open Questions\n- None at this time.\n\n## References\n- API: `navpath/api.py` `find_path()`\n- CLI: `navpath/__main__.py`\n- Options: `navpath/options.py` `SearchOptions`\n- Schema: `docs/tiles_nodes_schema.md` (see `requirements` and `*_nodes.requirement_id`)\n",
  "fileStats": {
    "size": 8348,
    "lines": 143,
    "lastModified": "2025-10-08T23:53:04.537Z"
  },
  "comments": []
}