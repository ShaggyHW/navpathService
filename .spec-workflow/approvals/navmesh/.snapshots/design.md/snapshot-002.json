{
  "id": "snapshot_1760119352618_gupymjgbk",
  "approvalId": "approval_1760119288935_t815j93l1",
  "approvalTitle": "Approve Revised Design for navmesh spec (tests removed)",
  "version": 2,
  "timestamp": "2025-10-10T18:02:32.618Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Design Document\n\n## Overview\n\nBuild a static, region-based navmesh from `worldReachableTiles.db` to shift computation from runtime to build-time. The build tool groups contiguous walkable tiles into deterministic regions and emits a compact SQLite database with region nodes and edges, including special connectors derived from nodes (doors, lodestones, object/NPC/ifslot/item). The output is optimized for fast neighbor queries during pathfinding.\n\nDeliverables:\n- CLI: `python -m navpath.navmesh_build` to produce `navmesh.db`.\n- SQLite schema: `nav_regions`, `nav_region_edges`, `region_tiles`, `metadata`.\n- Deterministic, idempotent build with provenance and validation summary.\n\n## Steering Document Alignment\n\n### Technical Standards (tech.md)\n- Parameterized SQLite, no raw string interpolation. Follow `navpath/db.py` practices.\n- Deterministic ordering, stable IDs. Prefer iterative streaming to avoid excessive RAM.\n- Logging with standard library.\n\n### Project Structure (structure.md)\n- New build package under `navpath/navmesh_build/` for modularity:\n  - `navmesh_build/__main__.py` (CLI entrypoint)\n  - `navmesh_build/regionizer.py` (tile→region grouping)\n  - `navmesh_build/connectors.py` (doors/lodestones/objects/npcs/ifslots/items → region edges)\n  - `navmesh_build/schema.py` (DDL and writers)\n  - `navmesh_build/provenance.py`\n  - `navmesh_build/report.py`\n- Optional runtime provider later: `navpath/region_graph.py` to consume `navmesh.db` (future phase, not part of this build deliverable).\n\n## Code Reuse Analysis\n\n### Existing Components to Leverage\n- **`navpath/db.py`**: Read-only access to `tiles` and node tables; reuse for input side.\n- **`navpath/options.py`**: Cost override knobs are informative for mapping default costs but not used at build-time; keep values in metadata.\n- **`navpath/cost.py`**: Constants help align default costs; build will not compute heuristics.\n- **`navpath/graph.py`**: Reference semantics for allowed directions, door/lodestone behavior, requirement gating. Use as behavioral source of truth when projecting node semantics onto regions.\n\n### Integration Points\n- **Input DB**: Reuse `Database` queries to stream tiles and nodes.\n- **Output DB**: New DDL via `schema.py`, batch inserts, and indexes per requirements.\n- **Future Runtime**: A `RegionGraphProvider` can read `navmesh.db` to provide neighbors; mirrors `SqliteGraphProvider` API.\n\n## Architecture\n\nThe builder operates in phases to ensure determinism and streaming behavior:\n\n1) Load input metadata and compute provenance hash of `worldReachableTiles.db` and config.\n2) Regionization per plane:\n   - Stream tiles in deterministic scan order (plane asc, y asc, x asc).\n   - Use union-find or flood-fill grouping based on 4-neighbor adjacency permitted by `allowed_directions`/`blocked_directions`.\n   - Do not cross door boundaries; treat blocked directions as hard boundaries; ignore diagonal-only contacts.\n   - Assign stable region IDs in discovery order per global ordering (plane, then min_y, min_x of region bounding box).\n   - Record tiles→region in `region_tiles`; accumulate per-region bbox and area.\n3) Build region adjacency edges:\n   - For each frontier between two regions that share at least one valid side transition, add a movement edge between regions.\n   - Weight: default movement cost as base (collapsed intra-region cost is 0; inter-region represents a step across a border). Store border sample coordinate in `meta` for traceability.\n4) Build special connectors via node preprocessing:\n   - Doors: map inside/outside tiles to their regions; add directed edges with type `door`, cost from node or default; propagate `direction`, `real_id_*`, `open_action`, requirement gating metadata.\n   - Lodestones: from any region to destination region (single edge) with type `lodestone` and cost; requirement gates.\n   - Objects/NPCs/Ifslots/Items: deterministically select a destination tile within bounds (as `graph._select_dest_tile` does) and map origin/destination to regions; create edges with chain metadata (if chains are resolved during build) or store only head and `next_node_*` metadata for runtime chain evaluation. For build, we store head metadata and raw node ids; full chain expansion can remain a runtime concern.\n5) Write schema and indexes; insert metadata and validation summary.\n\n```mermaid\nflowchart TD\n  A[Load input + provenance] --> B[Regionize tiles per plane]\n  B --> C[Compute region adjacencies]\n  C --> D[Extract special connectors]\n  D --> E[Write SQLite schema + indexes]\n  E --> F[Validation + report]\n```\n\n### Modular Design Principles\n- **Single File Responsibility**: Separate readers, regionizer, connectors, and writers.\n- **Component Isolation**: Builders produce plain data structures which writers persist.\n- **Service Layer Separation**: No direct SQL in algorithmic modules; use `schema.py` for persistence.\n\n## Components and Interfaces\n\n### `Regionizer`\n- **Purpose:** Group tiles into deterministic regions.\n- **Interfaces:**\n  - `build_regions(db: Database, planes: Optional[Set[int]]) -> Iterator[Region]`\n  - `Region` fields: `id`, `plane`, `bbox(min_x,min_y,max_x,max_y)`, `area`, `tiles: Iterable[Tile]`, `meta`.\n- **Dependencies:** `navpath/db.Database` for `tiles` streaming.\n\n### `AdjacencyBuilder`\n- **Purpose:** Discover neighboring region pairs and emit movement edges.\n- **Interfaces:** `build_adjacencies(regions_index) -> Iterator[RegionEdge]`\n- **Edge fields:** `src_region_id`, `dst_region_id`, `type=\"move\"`, `weight`, `meta` (e.g., `border_sample`).\n\n### `ConnectorExtractor`\n- **Purpose:** Convert node tables to region edges.\n- **Interfaces:** `extract_edges(db: Database, tile_to_region, config) -> Iterator[RegionEdge]`\n- **Dependencies:** `db.iter_*` methods; requirement gating logic aligned with `requirements.evaluate_requirement`.\n\n### `SchemaWriter`\n- **Purpose:** Create schema and batch insert rows.\n- **Interfaces:**\n  - `create_schema(conn)`\n  - `insert_regions(regions)`\n  - `insert_region_tiles(mappings)`\n  - `insert_edges(edges)`\n  - `insert_metadata(pairs)`\n\n### `Provenance`\n- **Purpose:** Record input path hash, schema snapshot, build timestamp, version, config hash.\n\n### `Report`\n- **Purpose:** Summarize counts and anomalies; warn and continue for recoverable issues.\n\n## Data Models\n\n### SQLite Tables\n- `nav_regions(id INTEGER PRIMARY KEY, plane INT, min_x INT, min_y INT, max_x INT, max_y INT, area INT, category TEXT, meta TEXT)`\n- `nav_region_edges(src_region_id INT, dst_region_id INT, weight REAL, type TEXT, meta TEXT)`\n- `region_tiles(region_id INT, x INT, y INT, plane INT)`\n- `metadata(key TEXT PRIMARY KEY, value TEXT)`\n\n### Indexes\n- `CREATE INDEX idx_regions_plane ON nav_regions(plane);`\n- `CREATE INDEX idx_region_tiles_xyz ON region_tiles(x,y,plane);`\n- `CREATE INDEX idx_region_edges_src ON nav_region_edges(src_region_id);`\n- `CREATE INDEX idx_region_edges_dst ON nav_region_edges(dst_region_id);`\n\n### ID Assignment\n- Regions get increasing IDs by (plane asc, region.min_y asc, region.min_x asc).\n- Edges are implicit rows; no PK required beyond rowid.\n\n## Algorithms\n\n### Regionization\n- Iterate tiles by (plane, y, x). A tile is walkable if `allowed_directions` resolves to non-zero.\n- For each unvisited walkable tile, BFS/DFS expand to neighbors permitted by the tile’s `allowed_directions`, respecting blocked directions and ignoring diagonal-only contacts.\n- Boundary handling:\n  - Do not traverse across door boundaries; doors create connectors, not membership.\n  - Multiple planes independent.\n- Determinism: scan/queue ordering is fixed; union-find merges in index order only.\n\n### Adjacency Discovery\n- For each tile at a region boundary, inspect 4-neighbors; if neighbor belongs to a different region and the transition is permitted both ways, record an adjacency (deduped by `(src,dst)`).\n- Edge weight: base movement cost (from `cost.DEFAULT_STEP_COST_MS`) or `1` if building in abstract units; store chosen base in `metadata`.\n\n### Connectors Extraction\n- Doors: directed edges between interior/exterior regions; include node ids, `direction`, `real_id_open/closed`, `open_action`, `requirement_id` in `meta`.\n- Lodestones: from any region to destination region; single edge per lodestone id.\n- Objects/NPCs/Ifslots/Items: pick deterministic destination tile within bounds (scan x then y); map to regions; store head node id and raw `next_node_*` fields in `meta`. Chain resolution can be runtime to keep build simpler and DB smaller.\n- Requirement gating: copy requirement metadata; evaluation is runtime concern.\n\n## Error Handling\n\n### Error Scenarios\n1. **Input missing or unreadable**\n   - Handling: exit non-zero; clear message.\n2. **Schema mismatch**\n   - Handling: detect via required columns; exit non-zero with hint.\n3. **Orphan specials** (dest tile doesn’t exist or no region)\n   - Handling: warn and skip; count in report.\n4. **DB locked / write failure**\n   - Handling: retry limited; fail non-zero if persistent.\n\n## Performance\n- Stream tiles per plane; avoid loading full map.\n- Batch inserts with executemany; wrap in transactions.\n- Pragmas when safe: `journal_mode=WAL`, `synchronous=NORMAL`.\n- Avoid N+1 by prefetching small node tables.\n## Determinism & Idempotence\n- Stable iteration order and seedless algorithms.\n- Sorted insertion order for all rows.\n- Region IDs derived only from discovered order/bounds; persisted mapping ensures reproducibility.\n\n## CLI and Configuration\n - Module: `navpath.navmesh_build` with flags:\n  - `--input PATH` (required), `--output PATH` (required)\n  - `--planes <list|all>`\n  - `--dry-run`, `--overwrite`\n  - Optional base costs: `--cost-base`, `--cost-door`, `--cost-lodestone`, etc. (stored in `metadata`)\n - Help text documents defaults and schema.\n",
  "fileStats": {
    "size": 9780,
    "lines": 177,
    "lastModified": "2025-10-10T18:00:55.380Z"
  },
  "comments": []
}