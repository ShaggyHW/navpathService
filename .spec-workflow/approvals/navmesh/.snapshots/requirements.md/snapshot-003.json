{
  "id": "snapshot_1760118970707_1satuifai",
  "approvalId": "approval_1760118818461_tfmfhr7xs",
  "approvalTitle": "Approve Updated Requirements for navmesh spec (region-based navmesh)",
  "version": 3,
  "timestamp": "2025-10-10T17:56:10.707Z",
  "trigger": "approved",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nA Python script and accompanying output schema to build a static navmesh database from the existing `worldReachableTiles.db`. The tool reads tile connectivity and special transition nodes (doors, lodestones, objects, NPCs, items), then generates a compact, indexed SQLite navmesh optimized for fast runtime pathfinding.\n\nValue: precomputing a navmesh shifts work from runtime to build-time, improving responsiveness and enabling consistent, reproducible pathfinding across planes.\n\n## Alignment with Product Vision\n\nThis feature provides a deterministic, reproducible navigation data source for `navpath` to consume. It reduces runtime computation and centralizes the logic for interpreting tiles and special traversal mechanics into a single build artifact.\n\n## Requirements\n\n### Requirement 1: Build navmesh region graph from tiles\n\n**User Story:** As a developer/operator, I want a CLI to generate a navmesh DB from `worldReachableTiles.db` using grouped walk regions so that runtime pathfinding is fast and consistent.\n\n#### Acceptance Criteria\n\n1. WHEN the CLI is executed with `--input <path/to/worldReachableTiles.db>` and `--output <path/to/navmesh.db>` THEN the system SHALL create a new SQLite database at the output path.\n2. WHEN reading `tiles(x,y,plane,allowed_directions,blocked_directions,category,tiledata)` THEN the system SHALL compute walk regions by grouping contiguous walkable tiles per plane using a deterministic flood-fill/union-find. `blocked_directions` SHALL be treated as boundaries. Regions SHALL not be merged across diagonal-only contacts (must share a side transition) and SHALL not merge across door boundaries by default.\n3. The system SHALL produce a region graph where each region is a node. Intra-region movements are collapsed; adjacency edges SHALL only exist between neighboring regions that share at least one valid tile-to-tile transition on the border.\n4. The system SHALL preprocess node tables to generate region connectors: doors connect interior/exterior regions; lodestones connect from any region to the destination region (subject to requirements and design in Requirement 2); object/NPC/ifslot/item nodes map origin/destination bounds deterministically to source/destination regions, preserving original node identifiers in metadata.\n5. The system SHALL persist a mapping from tiles to their region for traceability and coordinate localization.\n6. The system SHALL support multiple planes and generate cross-plane edges only when defined by special transitions (see Requirement 2).\n7. The output DB SHALL include indexes to support fast lookups by region id and coordinate-to-region mapping.\n\n### Requirement 2: Integrate special transitions from node tables\n\n**User Story:** As a pathfinding engineer, I want special transitions (doors, teleports, object/NPC interactions, UI slots, items) represented as weighted edges so that routes can traverse interactable mechanics when allowed.\n\n#### Acceptance Criteria\n\n1. GIVEN `door_nodes` THEN the system SHALL add directed edges between interior/exterior tiles based on `direction` and locations, honoring `requirement_id` and applying `cost` when present.\n2. GIVEN `lodestone_nodes` THEN the system SHALL add teleport edges from any coordinate within the lodestoneâ€™s origin semantics (by design) to `dest_x,dest_y,dest_plane`, with optional `cost` and requirement gating.\n3. GIVEN `object_nodes` and `npc_nodes` THEN the system SHALL add edges into destination bounds (`dest_min/max_x/y`, `dest_plane`) from origin bounds (if specified) honoring `match_type`, `action`, requirement, and `search_radius` semantics.\n4. GIVEN `ifslot_nodes` and `item_nodes` THEN the system SHALL add edges that represent UI and item-triggered transitions into specified destination bounds and planes with optional `cost` and requirement gating.\n5. WHEN `requirement_id` references `requirements(id)` THEN the system SHALL encode gating metadata and exclude such edges unless requirements are considered satisfied at evaluation time (persist condition in edge metadata; evaluation policy is runtime concern).\n6. All special transition edges SHALL be typed (e.g., `door|lodestone|object|npc|ifslot|item`) and preserve source node identifiers in metadata for traceability.\n\n### Requirement 3: Cost model\n\n**User Story:** As a developer, I want consistent traversal costs so that pathfinding prefers efficient routes and uses specials when beneficial.\n\n#### Acceptance Criteria\n\n1. The system SHALL assign base grid-move cost (default 1) to tile adjacency edges.\n2. The system SHALL assign special edges their `cost` if specified; otherwise default to a configured special-edge base (default 1 unless otherwise configured per type).\n3. The CLI SHALL support optional cost multipliers: `--cost-base <n>`, `--cost-door <n>`, `--cost-lodestone <n>`, etc.\n\n### Requirement 4: Determinism and idempotence\n\n**User Story:** As an operator, I want reproducible outputs so that builds are verifiable and cacheable.\n\n#### Acceptance Criteria\n\n1. GIVEN the same input DB and config, THEN the output `navmesh.db` SHALL be byte-for-byte identical (aside from timestamps) across runs.\n2. The output DB SHALL record provenance in `metadata` (input path hash, source schema snapshot, build timestamp, tool version, config hash).\n\n### Requirement 5: Validation, reporting, and safety\n\n**User Story:** As a maintainer, I want clear logs and summary stats to validate the build.\n\n#### Acceptance Criteria\n\n1. The CLI SHALL print a build summary: cells count, edges count (grid/special by type), planes, and counts per transition type.\n2. The system SHALL warn on orphan specials (e.g., destination outside any `tiles` record) and skip invalid edges.\n3. The build SHALL fail with nonzero exit code for unrecoverable errors (input missing, DB locked, schema mismatch).\n\n### Requirement 6: CLI and configuration\n\n**User Story:** As a user, I need a straightforward interface to run the build locally or in CI.\n\n#### Acceptance Criteria\n\n1. CLI name: `python -m navpath.navmesh_build` (or `navmesh_build.py` entrypoint) with options:\n   - `--input PATH` (required)\n   - `--output PATH` (required)\n   - `--planes <list|all>` filter (optional)\n   - `--dry-run` (compute stats only; no DB write)\n   - `--overwrite` (allow replacing existing output)\n   - cost flags from Requirement 3\n2. Help text (`-h/--help`) SHALL describe all options and defaults.\n\n### Requirement 7: Output schema\n\n**User Story:** As a consumer service, I want a compact schema to query neighbors and costs efficiently.\n\n#### Acceptance Criteria\n\n1. The output SQLite DB SHALL include tables:\n   - `nav_regions(id INTEGER PRIMARY KEY, plane INT, min_x INT, min_y INT, max_x INT, max_y INT, area INT, category TEXT, meta TEXT)` where `meta` is JSON (e.g., region generation hints).\n   - `nav_region_edges(src_region_id INT, dst_region_id INT, weight REAL, type TEXT, meta TEXT)` where `meta` is JSON (original node ids, requirements, action, chain metadata, etc.).\n   - `region_tiles(region_id INT, x INT, y INT, plane INT)` mapping tiles to their parent region for traceability.\n   - `metadata(key TEXT PRIMARY KEY, value TEXT)`\n2. Indexes SHALL be created:\n   - `CREATE INDEX idx_regions_plane ON nav_regions(plane);`\n   - `CREATE INDEX idx_region_tiles_xyz ON region_tiles(x,y,plane);`\n   - `CREATE INDEX idx_region_edges_src ON nav_region_edges(src_region_id);`\n   - `CREATE INDEX idx_region_edges_dst ON nav_region_edges(dst_region_id);`\n3. Foreign keys optional for performance; integrity ensured by build process.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Single Responsibility: separate modules for input schema reading, graph construction, special extractors, and DB writing.\n- Modular Design: pluggable extractor per node table (`door`, `lodestone`, `object`, `npc`, `ifslot`, `item`).\n- Clear Interfaces: define `CellBuilder`, `EdgeBuilder`, and per-extractor interfaces.\n\n### Performance\n- Streamed processing by plane/region to limit memory usage.\n- Batch inserts and `PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL;` when safe.\n- Avoid N+1 queries; use prepared statements.\n\n### Security\n- Only local file IO; no network access.\n- Validate input paths; do not execute arbitrary SQL from the input.\n\n### Reliability\n- Use transactions with chunked commits; rollback on fatal errors.\n- Deterministic iteration order (sorted coordinates, stable ids).\n\n### Usability\n- Progress output per phase; clear warnings and actionable errors.\n- Configuration via CLI flags and optional `toml`/`yaml` config file.\n",
  "fileStats": {
    "size": 8614,
    "lines": 127,
    "lastModified": "2025-10-10T17:53:10.684Z"
  },
  "comments": []
}