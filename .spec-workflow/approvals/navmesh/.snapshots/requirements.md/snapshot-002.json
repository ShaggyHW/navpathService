{
  "id": "snapshot_1760118493184_kx164zsoe",
  "approvalId": "approval_1760117481019_tkf26mgjq",
  "approvalTitle": "Approve Requirements for navmesh spec",
  "version": 2,
  "timestamp": "2025-10-10T17:48:13.184Z",
  "trigger": "revision_requested",
  "status": "pending",
  "content": "# Requirements Document\n\n## Introduction\n\nA Python script and accompanying output schema to build a static navmesh database from the existing `worldReachableTiles.db`. The tool reads tile connectivity and special transition nodes (doors, lodestones, objects, NPCs, items), then generates a compact, indexed SQLite navmesh optimized for fast runtime pathfinding.\n\nValue: precomputing a navmesh shifts work from runtime to build-time, improving responsiveness and enabling consistent, reproducible pathfinding across planes.\n\n## Alignment with Product Vision\n\nThis feature provides a deterministic, reproducible navigation data source for `navpath` to consume. It reduces runtime computation and centralizes the logic for interpreting tiles and special traversal mechanics into a single build artifact.\n\n## Requirements\n\n### Requirement 1: Build navmesh graph from tiles\n\n**User Story:** As a developer/operator, I want a CLI to generate a navmesh DB from `worldReachableTiles.db` so that runtime pathfinding is fast and consistent.\n\n#### Acceptance Criteria\n\n1. WHEN the CLI is executed with `--input <path/to/worldReachableTiles.db>` and `--output <path/to/navmesh.db>` THEN the system SHALL create a new SQLite database at the output path.\n2. WHEN reading `tiles(x,y,plane,allowed_directions,blocked_directions,category,tiledata)` THEN the system SHALL create navmesh cells for each `(x,y,plane)` and 4/8-neighbor edges consistent with allowed/blocked directions.\n3. IF `allowed_directions` is present THEN the system SHALL restrict edges to only those listed; IF `blocked_directions` is present THEN the system SHALL remove edges listed.\n4. The system SHALL support multiple planes and generate cross-plane edges only when defined by special transitions (see Requirement 2).\n5. The output DB SHALL include indexes to support fast edge lookups by cell id and coordinate.\n\n### Requirement 2: Integrate special transitions from node tables\n\n**User Story:** As a pathfinding engineer, I want special transitions (doors, teleports, object/NPC interactions, UI slots, items) represented as weighted edges so that routes can traverse interactable mechanics when allowed.\n\n#### Acceptance Criteria\n\n1. GIVEN `door_nodes` THEN the system SHALL add directed edges between interior/exterior tiles based on `direction` and locations, honoring `requirement_id` and applying `cost` when present.\n2. GIVEN `lodestone_nodes` THEN the system SHALL add teleport edges from any coordinate within the lodestoneâ€™s origin semantics (by design) to `dest_x,dest_y,dest_plane`, with optional `cost` and requirement gating.\n3. GIVEN `object_nodes` and `npc_nodes` THEN the system SHALL add edges into destination bounds (`dest_min/max_x/y`, `dest_plane`) from origin bounds (if specified) honoring `match_type`, `action`, requirement, and `search_radius` semantics.\n4. GIVEN `ifslot_nodes` and `item_nodes` THEN the system SHALL add edges that represent UI and item-triggered transitions into specified destination bounds and planes with optional `cost` and requirement gating.\n5. WHEN `requirement_id` references `requirements(id)` THEN the system SHALL encode gating metadata and exclude such edges unless requirements are considered satisfied at evaluation time (persist condition in edge metadata; evaluation policy is runtime concern).\n6. All special transition edges SHALL be typed (e.g., `door|lodestone|object|npc|ifslot|item`) and preserve source node identifiers in metadata for traceability.\n\n### Requirement 3: Cost model\n\n**User Story:** As a developer, I want consistent traversal costs so that pathfinding prefers efficient routes and uses specials when beneficial.\n\n#### Acceptance Criteria\n\n1. The system SHALL assign base grid-move cost (default 1) to tile adjacency edges.\n2. The system SHALL assign special edges their `cost` if specified; otherwise default to a configured special-edge base (default 1 unless otherwise configured per type).\n3. The CLI SHALL support optional cost multipliers: `--cost-base <n>`, `--cost-door <n>`, `--cost-lodestone <n>`, etc.\n\n### Requirement 4: Determinism and idempotence\n\n**User Story:** As an operator, I want reproducible outputs so that builds are verifiable and cacheable.\n\n#### Acceptance Criteria\n\n1. GIVEN the same input DB and config, THEN the output `navmesh.db` SHALL be byte-for-byte identical (aside from timestamps) across runs.\n2. The output DB SHALL record provenance in `metadata` (input path hash, source schema snapshot, build timestamp, tool version, config hash).\n\n### Requirement 5: Validation, reporting, and safety\n\n**User Story:** As a maintainer, I want clear logs and summary stats to validate the build.\n\n#### Acceptance Criteria\n\n1. The CLI SHALL print a build summary: cells count, edges count (grid/special by type), planes, and counts per transition type.\n2. The system SHALL warn on orphan specials (e.g., destination outside any `tiles` record) and skip invalid edges.\n3. The build SHALL fail with nonzero exit code for unrecoverable errors (input missing, DB locked, schema mismatch).\n\n### Requirement 6: CLI and configuration\n\n**User Story:** As a user, I need a straightforward interface to run the build locally or in CI.\n\n#### Acceptance Criteria\n\n1. CLI name: `python -m navpath.navmesh_build` (or `navmesh_build.py` entrypoint) with options:\n   - `--input PATH` (required)\n   - `--output PATH` (required)\n   - `--planes <list|all>` filter (optional)\n   - `--dry-run` (compute stats only; no DB write)\n   - `--overwrite` (allow replacing existing output)\n   - cost flags from Requirement 3\n2. Help text (`-h/--help`) SHALL describe all options and defaults.\n\n### Requirement 7: Output schema\n\n**User Story:** As a consumer service, I want a compact schema to query neighbors and costs efficiently.\n\n#### Acceptance Criteria\n\n1. The output SQLite DB SHALL include tables:\n   - `nav_cells(id INTEGER PRIMARY KEY, x INT, y INT, plane INT, category TEXT, tiledata INT)`\n   - `nav_edges(src_id INT, dst_id INT, weight REAL, type TEXT, meta TEXT)` where `meta` is JSON (original node ids, requirements, action, etc.)\n   - `metadata(key TEXT PRIMARY KEY, value TEXT)`\n2. Indexes SHALL be created:\n   - `CREATE INDEX idx_cells_xyz ON nav_cells(x,y,plane);`\n   - `CREATE INDEX idx_edges_src ON nav_edges(src_id);`\n   - `CREATE INDEX idx_edges_dst ON nav_edges(dst_id);`\n3. Foreign keys optional for performance; integrity ensured by build process.\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n- Single Responsibility: separate modules for input schema reading, graph construction, special extractors, and DB writing.\n- Modular Design: pluggable extractor per node table (`door`, `lodestone`, `object`, `npc`, `ifslot`, `item`).\n- Clear Interfaces: define `CellBuilder`, `EdgeBuilder`, and per-extractor interfaces.\n\n### Performance\n- Streamed processing by plane/region to limit memory usage.\n- Batch inserts and `PRAGMA journal_mode=WAL; PRAGMA synchronous=NORMAL;` when safe.\n- Avoid N+1 queries; use prepared statements.\n\n### Security\n- Only local file IO; no network access.\n- Validate input paths; do not execute arbitrary SQL from the input.\n\n### Reliability\n- Use transactions with chunked commits; rollback on fatal errors.\n- Deterministic iteration order (sorted coordinates, stable ids).\n\n### Usability\n- Progress output per phase; clear warnings and actionable errors.\n- Configuration via CLI flags and optional `toml`/`yaml` config file.\n",
  "fileStats": {
    "size": 7441,
    "lines": 123,
    "lastModified": "2025-10-10T17:30:55.423Z"
  },
  "comments": []
}